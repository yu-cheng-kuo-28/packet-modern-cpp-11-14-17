$ ./03_lambda_evolution_demo_cpp20

Lambda Evolution: Practical Applications
=====================================

=== PRACTICAL: Lambda Evolution in Data Processing ===
Task: Process data pipeline (filter → transform → reduce)
Input: {1, -2, 3, -4, 5, -6, 7, -8, 9, -10}

=== C++11 Approach (Verbose) ===

--- C++11: What you CAN do ---
  Pipeline: filter positives → square → sum
  Positive numbers: 1 3 5 7 9
  Squared: 1 9 25 49 81
  Sum: 165
  ✅ Explicit types work
  ✅ Separate steps work

--- C++11: What you CANNOT do ---
  // ❌ C++11: Generic lambdas - ILLEGAL
  // auto is_positive = [](auto x) { return x > 0; }; // ERROR!
  // ❌ C++11: Init capture - ILLEGAL
  // auto processor = [factor = 2](int x) { return x * factor; }; // ERROR!
  // ❌ C++11: Constexpr - ILLEGAL
  // constexpr auto square = [](int x) constexpr { return x * x; }; // ERROR!

=== C++14 Approach (Generic & Flexible) ===

--- C++14: NEW features that are now LEGAL ---
  Pipeline: combined filter + transform + reduce
  Sum of squared positives: 165
  Sum of doubled positives: 50
  ✅ NEW: Generic lambdas with auto parameters
  ✅ NEW: Init capture for inline variables
  ✅ NEW: Auto return type deduction

--- C++14: What you STILL CANNOT do ---
  // ❌ C++14: Constexpr lambdas - STILL ILLEGAL
  // constexpr auto square = [](auto x) constexpr { return x * x; }; // ERROR!
  // ❌ C++14: Template parameters - STILL ILLEGAL
  // auto lambda = []<typename T>(T x) { return x * x; }; // ERROR!

=== C++17 Approach (Constexpr & Performance) ===

--- C++17: NEW features that are now LEGAL ---
  Pipeline: constexpr processing for optimization
  Sum of squared positives: 165
  Compile-time demo: process_value(5) = 25
  ✅ NEW: Constexpr lambdas
  ✅ NEW: Compile-time computation
  ✅ NEW: Performance optimizations

--- C++17: What you STILL CANNOT do ---
  // ❌ C++17: Template parameters - STILL ILLEGAL
  // auto lambda = []<typename T>(T x) { return x * x; }; // ERROR!
  // ❌ C++17: Concepts - STILL ILLEGAL
  // auto lambda = []<typename T>(T x) requires std::is_arithmetic_v<T> { ... }; // ERROR!

=== C++20 Approach (Type-Safe & Advanced) ===

--- C++20: NEW features that are now LEGAL ---
  Pipeline: type-safe template lambda with concepts
  Sum of squared positives: 165
  ✅ NEW: Template lambdas
  ✅ NEW: Concepts integration
  ✅ NEW: Type safety guarantees

  // This would cause a compile error:
  // safe_processor(std::vector<std::string>{"a"}, pred, trans); // ❌ ERROR: string not arithmetic   


=== Lambda Evolution Summary ===

C++11 - The Foundation:
  ✅ Basic lambdas with explicit types
  ✅ Simple captures
  ❌ No generic lambdas
  ❌ No init capture
  ❌ No constexpr
  ❌ No templates

C++14 - Generic Power:
  ✅ All C++11 features
  ✅ NEW: Generic lambdas (auto params)
  ✅ NEW: Init captures
  ✅ NEW: Auto return type deduction
  ❌ No constexpr
  ❌ No templates

C++17 - Compile-time:
  ✅ All C++14 features
  ✅ NEW: Constexpr lambdas
  ✅ NEW: Structured bindings
  ✅ NEW: Enhanced algorithms
  ❌ No template parameters
  ❌ No concepts

C++20 - Template Meta-programming:
  ✅ All C++17 features
  ✅ NEW: Template lambdas
  ✅ NEW: Concepts integration
  ✅ NEW: Pack expansion
  ✅ NEW: Advanced type constraints

Conclusion: Each C++ version makes lambdas more powerful and elegant!